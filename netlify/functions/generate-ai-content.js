/**
 * Netlify Function: AI Content Generation
 * Handles the complete AI content generation workflow with real-time updates
 */

const { createClient } = require('@supabase/supabase-js');

const supabaseUrl = process.env.VITE_SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
const huggingFaceToken = process.env.HF_ACCESS_TOKEN;
const cohereApiKey = process.env.COHERE_API_KEY;

// Initialize Supabase client with service role
const supabase = createClient(supabaseUrl, supabaseServiceKey);

// The 3 prompts to rotate between
const CONTENT_PROMPTS = [
  "Generate a 1000 word article on {keyword} including the {anchorText} hyperlinked to {targetUrl}",
  "Write a 1000 word blog post about {keyword} with a hyperlinked {anchorText} linked to {targetUrl}",
  "Produce a 1000-word reader friendly post on {keyword} that links {anchorText} to {targetUrl}"
];

// Helper function to generate content with Hugging Face
async function generateWithHuggingFace(prompt) {
  try {
    const response = await fetch(
      'https://api-inference.huggingface.co/models/microsoft/DialoGPT-large',
      {
        headers: {
          'Authorization': `Bearer ${huggingFaceToken}`,
          'Content-Type': 'application/json',
        },
        method: 'POST',
        body: JSON.stringify({
          inputs: prompt,
          parameters: {
            max_length: 2000,
            temperature: 0.7,
            do_sample: true,
            top_p: 0.9
          }
        }),
      }
    );

    if (!response.ok) {
      throw new Error(`Hugging Face API error: ${response.status}`);
    }

    const result = await response.json();
    
    if (result.error) {
      throw new Error(`Hugging Face error: ${result.error}`);
    }

    return result[0]?.generated_text || result.generated_text || '';
  } catch (error) {
    console.error('Hugging Face generation failed:', error);
    throw error;
  }
}

// Helper function to generate content with Cohere
async function generateWithCohere(prompt) {
  try {
    const response = await fetch('https://api.cohere.ai/v1/generate', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${cohereApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'command',
        prompt: prompt,
        max_tokens: 2000,
        temperature: 0.7,
        k: 0,
        stop_sequences: [],
        return_likelihoods: 'NONE'
      })
    });

    if (!response.ok) {
      throw new Error(`Cohere API error: ${response.status}`);
    }

    const result = await response.json();
    
    if (result.generations && result.generations.length > 0) {
      return result.generations[0].text;
    }
    
    throw new Error('No content generated by Cohere');
  } catch (error) {
    console.error('Cohere generation failed:', error);
    throw error;
  }
}

// Test API connectivity
async function testAPIs() {
  const results = { huggingface: false, cohere: false };

  // Test Hugging Face
  try {
    await generateWithHuggingFace('Test prompt');
    results.huggingface = true;
  } catch (error) {
    console.warn('Hugging Face test failed:', error.message);
  }

  // Test Cohere
  try {
    await generateWithCohere('Test prompt');
    results.cohere = true;
  } catch (error) {
    console.warn('Cohere test failed:', error.message);
  }

  return results;
}

// Generate SEO-friendly content
function enhanceContentForSEO(content, keyword, anchorText, targetUrl) {
  // Add basic HTML structure if not present
  if (!content.includes('<h1>') && !content.includes('<h2>')) {
    const title = `Complete Guide to ${keyword.charAt(0).toUpperCase() + keyword.slice(1)}`;
    content = `<h1>${title}</h1>\n\n${content}`;
  }

  // Ensure anchor text is linked
  if (!content.includes(anchorText) || !content.includes(targetUrl)) {
    // Add a natural paragraph with the link
    const linkParagraph = `\n\n<p>For more information about this topic, check out our comprehensive resource on <a href="${targetUrl}" target="_blank" rel="noopener noreferrer">${anchorText}</a>.</p>`;
    content += linkParagraph;
  }

  // Add proper paragraph tags if missing
  content = content.replace(/\n\n/g, '</p>\n<p>');
  if (!content.startsWith('<p>') && !content.startsWith('<h')) {
    content = '<p>' + content;
  }
  if (!content.endsWith('</p>') && !content.endsWith('>')) {
    content = content + '</p>';
  }

  return content;
}

// Calculate basic SEO metrics
function calculateSEOMetrics(content, keyword) {
  const text = content.replace(/<[^>]*>/g, ''); // Strip HTML
  const words = text.split(/\s+/).filter(word => word.length > 0);
  const wordCount = words.length;
  
  // Calculate keyword density
  const keywordOccurrences = text.toLowerCase().split(keyword.toLowerCase()).length - 1;
  const keywordDensity = (keywordOccurrences / words.length) * 100;
  
  // Calculate basic SEO score
  let seoScore = 0;
  if (content.includes('<h1>')) seoScore += 20;
  if (content.includes('<h2>') || content.includes('<h3>')) seoScore += 15;
  if (keywordOccurrences >= 3 && keywordOccurrences <= 8) seoScore += 25;
  if (wordCount >= 800) seoScore += 20;
  if (content.includes('<p>')) seoScore += 10;
  if (content.includes('<a href=')) seoScore += 10;
  
  return {
    wordCount,
    keywordDensity: Math.round(keywordDensity * 100) / 100,
    seoScore: Math.min(seoScore, 100),
    readingTime: Math.ceil(wordCount / 200)
  };
}

// Generate URL-friendly slug
function generateSlug(title, keyword) {
  const baseSlug = (title || keyword)
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .trim()
    .substring(0, 60);
  
  return `${baseSlug}-${Date.now()}`;
}

exports.handler = async (event, context) => {
  // Set CORS headers
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Content-Type': 'application/json'
  };

  // Handle CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return { statusCode: 200, headers, body: '' };
  }

  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    const { keyword, anchorText, targetUrl, userId } = JSON.parse(event.body);

    // Validate input
    if (!keyword || !anchorText || !targetUrl) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          success: false,
          error: 'Missing required fields: keyword, anchorText, targetUrl'
        })
      };
    }

    // Check user limit (one per account)
    if (userId) {
      const { data: existingPosts } = await supabase
        .from('ai_generated_posts')
        .select('id')
        .eq('generated_by_account', userId)
        .limit(1);

      if (existingPosts && existingPosts.length > 0) {
        return {
          statusCode: 400,
          headers,
          body: JSON.stringify({
            success: false,
            error: 'Account has already used their one-time content generation limit'
          })
        };
      }
    }

    const startTime = Date.now();

    // Test API availability
    console.log('Testing API connectivity...');
    const apiStatus = await testAPIs();

    if (!apiStatus.huggingface && !apiStatus.cohere) {
      return {
        statusCode: 503,
        headers,
        body: JSON.stringify({
          success: false,
          error: 'No AI providers are currently available'
        })
      };
    }

    // Select provider (Hugging Face primary, Cohere backup)
    const useHuggingFace = apiStatus.huggingface;
    const provider = useHuggingFace ? 'huggingface' : 'cohere';

    console.log(`Using provider: ${provider}`);

    // Get random prompt
    const promptTemplate = CONTENT_PROMPTS[Math.floor(Math.random() * CONTENT_PROMPTS.length)];
    
    // Build the full prompt
    const basePrompt = promptTemplate
      .replace('{keyword}', keyword)
      .replace('{anchorText}', anchorText)
      .replace('{targetUrl}', targetUrl);

    const fullPrompt = `${basePrompt}

Please follow these SEO best practices:
1. Use H1, H2, H3 headings appropriately
2. Include the keyword "${keyword}" naturally throughout the content
3. Write in a conversational, engaging tone
4. Include relevant subheadings
5. Add a compelling introduction and conclusion
6. Ensure the anchor text "${anchorText}" is naturally integrated with the link to ${targetUrl}
7. Make the content readable and valuable to users
8. Use proper paragraph breaks and formatting
9. Include relevant keywords and semantic variations
10. Write exactly 1000 words

Format the response as clean HTML with proper semantic structure.`;

    // Generate content
    console.log('Generating content...');
    let content;
    try {
      if (useHuggingFace) {
        content = await generateWithHuggingFace(fullPrompt);
      } else {
        content = await generateWithCohere(fullPrompt);
      }
    } catch (error) {
      // Try backup provider
      console.log('Primary provider failed, trying backup...');
      const backupProvider = useHuggingFace ? 'cohere' : 'huggingface';
      
      if ((useHuggingFace && apiStatus.cohere) || (!useHuggingFace && apiStatus.huggingface)) {
        if (backupProvider === 'cohere') {
          content = await generateWithCohere(fullPrompt);
        } else {
          content = await generateWithHuggingFace(fullPrompt);
        }
      } else {
        throw new Error(`Content generation failed: ${error.message}`);
      }
    }

    // Enhance content for SEO
    content = enhanceContentForSEO(content, keyword, anchorText, targetUrl);

    // Calculate metrics
    const metrics = calculateSEOMetrics(content, keyword);

    // Extract/generate title
    const h1Match = content.match(/<h1[^>]*>(.*?)<\/h1>/i);
    const title = h1Match 
      ? h1Match[1].replace(/<[^>]*>/g, '') 
      : `Complete Guide to ${keyword.charAt(0).toUpperCase() + keyword.slice(1)}`;

    // Generate slug
    const slug = generateSlug(title, keyword);

    // Set expiration to 24 hours from now
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 24);

    const generationTime = Date.now() - startTime;

    // Save to database
    console.log('Saving to database...');
    const { data: savedPost, error: saveError } = await supabase
      .from('ai_generated_posts')
      .insert([{
        title,
        slug,
        content,
        keyword,
        anchor_text: anchorText,
        target_url: targetUrl,
        word_count: metrics.wordCount,
        provider,
        generation_time: generationTime,
        seo_score: metrics.seoScore,
        reading_time: metrics.readingTime,
        keyword_density: metrics.keywordDensity,
        expires_at: expiresAt.toISOString(),
        generated_by_account: userId,
        status: 'published'
      }])
      .select()
      .single();

    if (saveError) {
      console.error('Error saving post:', saveError);
      return {
        statusCode: 500,
        headers,
        body: JSON.stringify({
          success: false,
          error: 'Failed to save generated content',
          details: saveError.message
        })
      };
    }

    // Return success response
    const result = {
      success: true,
      content,
      title,
      slug,
      publishedUrl: `/blog/${slug}`,
      wordCount: metrics.wordCount,
      provider,
      generationTime,
      expiresAt: expiresAt.toISOString(),
      metadata: {
        seoScore: metrics.seoScore,
        readingTime: metrics.readingTime,
        keywordDensity: metrics.keywordDensity
      }
    };

    console.log('Content generation completed successfully');

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(result)
    };

  } catch (error) {
    console.error('Error in AI content generation:', error);

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        success: false,
        error: 'Failed to generate content',
        message: error.message,
        timestamp: new Date().toISOString()
      })
    };
  }
};
