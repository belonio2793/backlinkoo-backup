// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { SecureConfig } from '../../lib/secure-config';

// Get Supabase configuration with proper fallback
const getSupabaseConfig = () => {
  const envUrl = import.meta.env.VITE_SUPABASE_URL;
  const envKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

  console.log('üîß Environment variables:', {
    hasEnvUrl: !!envUrl,
    hasEnvKey: !!envKey,
    envUrlLength: envUrl?.length || 0,
    envKeyLength: envKey?.length || 0
  });

  const url = envUrl || SecureConfig.SUPABASE_URL;
  const key = envKey || SecureConfig.SUPABASE_ANON_KEY;

  console.log('üîß Final config:', {
    url: url ? `${url.substring(0, 30)}...` : 'missing',
    keyPrefix: key ? key.substring(0, 10) + '...' : 'missing',
    urlFromEnv: !!envUrl,
    keyFromEnv: !!envKey
  });

  return { url, key };
};

const { url: SUPABASE_URL, key: SUPABASE_PUBLISHABLE_KEY } = getSupabaseConfig();

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Create a mock client for development when Supabase project is not available
const createMockSupabaseClient = () => {
  const mockUser = {
    id: 'mock-user-id',
    email: 'test@example.com',
    user_metadata: { display_name: 'Test User' },
    created_at: new Date().toISOString(),
    aud: 'authenticated'
  };

  const mockSession = {
    access_token: 'mock-access-token',
    refresh_token: 'mock-refresh-token',
    user: mockUser
  };

  const mockAuth = {
    getSession: () => {
      console.warn('‚ö†Ô∏è Mock auth getSession called - using fake session');
      return Promise.resolve({ data: { session: null }, error: { message: 'Mock mode: Please configure real Supabase credentials' } });
    },
    getUser: () => {
      console.warn('‚ö†Ô∏è Mock auth getUser called');
      return Promise.resolve({ data: { user: null }, error: { message: 'Mock mode: Please configure real Supabase credentials' } });
    },
    onAuthStateChange: (callback: any) => {
      console.warn('‚ö†Ô∏è Mock auth onAuthStateChange called');
      return { data: { subscription: { unsubscribe: () => console.log('Mock auth listener unsubscribed') } } };
    },
    signInWithPassword: () => {
      console.error('‚ö†Ô∏è Mock auth signInWithPassword called - login will fail');
      return Promise.resolve({
        data: { user: null, session: null },
        error: { message: 'Authentication not available: Please configure real Supabase credentials in environment variables' }
      });
    },
    signUp: () => {
      console.error('‚ö†Ô∏è Mock auth signUp called - signup will fail');
      return Promise.resolve({
        data: { user: null, session: null },
        error: { message: 'Authentication not available: Please configure real Supabase credentials in environment variables' }
      });
    },
    signOut: () => {
      console.log('‚ö†Ô∏è Mock auth signOut called');
      return Promise.resolve({ error: null });
    },
    resend: () => {
      console.error('‚ö†Ô∏è Mock auth resend called');
      return Promise.resolve({ error: { message: 'Email service not available in mock mode' } });
    },
    resetPasswordForEmail: () => {
      console.error('‚ö†Ô∏è Mock auth resetPasswordForEmail called');
      return Promise.resolve({ error: { message: 'Password reset not available in mock mode' } });
    },
    verifyOtp: () => {
      console.error('‚ö†Ô∏è Mock auth verifyOtp called');
      return Promise.resolve({
        data: { user: null, session: null },
        error: { message: 'OTP verification not available in mock mode' }
      });
    },

  };

  const mockFrom = (table: string) => {
    const mockMethods = {
      select: (columns?: string) => mockMethods,
      insert: (data: any) => mockMethods,
      update: (data: any) => mockMethods,
      delete: () => mockMethods,
      upsert: (data: any) => mockMethods,
      eq: (column: string, value: any) => mockMethods,
      order: (column: string, options?: any) => mockMethods,
      limit: (count: number) => mockMethods,
      filter: (column: string, operator: string, value: any) => mockMethods,
      gte: (column: string, value: any) => mockMethods,
      lte: (column: string, value: any) => mockMethods,
      gt: (column: string, value: any) => mockMethods,
      lt: (column: string, value: any) => mockMethods,
      in: (column: string, values: any[]) => mockMethods,
      is: (column: string, value: any) => mockMethods,
      neq: (column: string, value: any) => mockMethods,
      ilike: (column: string, pattern: string) => mockMethods,
      like: (column: string, pattern: string) => mockMethods,
      range: (from: number, to: number) => mockMethods,
      single: () => Promise.resolve({ data: { id: 'mock-id', ...mockUser }, error: null }),
      then: (callback: any) => {
        console.warn(`‚ö†Ô∏è Mock database query on table '${table}' - no real data available`);
        // Return mock error to indicate database is not available
        return callback({
          data: null,
          error: { message: `Database not available: Please configure real Supabase credentials. Attempted to query table: ${table}` }
        });
      }
    };
    return mockMethods;
  };

  const mockFunctions = {
    invoke: () => Promise.resolve({ data: null, error: { message: 'Mock mode - functions disabled' } }),
  };

  const mockChannel = () => ({
    on: () => mockChannel(),
    subscribe: () => {},
  });

  return {
    auth: mockAuth,
    from: mockFrom,
    functions: mockFunctions,
    channel: mockChannel,
    removeChannel: () => {},
    rpc: () => Promise.resolve({ data: null, error: { message: 'Mock mode - RPC disabled' } }),
  };
};

// Check if we have valid Supabase credentials - improved validation
const validateCredentials = () => {
  console.log('üîç Validating Supabase credentials...');

  if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
    console.error('‚ùå Missing URL or key');
    return false;
  }

  if (SUPABASE_URL.trim() === "" || SUPABASE_PUBLISHABLE_KEY.trim() === "") {
    console.error('‚ùå Empty URL or key');
    return false;
  }

  if (SUPABASE_URL.includes('your-project-url') || SUPABASE_PUBLISHABLE_KEY.includes('your-anon-key')) {
    console.error('‚ùå Placeholder values detected');
    return false;
  }

  if (!SUPABASE_URL.startsWith('https://')) {
    console.error('‚ùå URL must start with https://');
    return false;
  }

  if (!SUPABASE_URL.includes('.supabase.co')) {
    console.error('‚ùå URL must be a supabase.co domain');
    return false;
  }

  if (!SUPABASE_PUBLISHABLE_KEY.startsWith('eyJ')) {
    console.error('‚ùå Key must be a valid JWT token');
    return false;
  }

  if (SUPABASE_PUBLISHABLE_KEY.length < 50) {
    console.error('‚ùå Key too short');
    return false;
  }

  console.log('‚úÖ Credentials validation passed');
  return true;
};

const hasValidCredentials = validateCredentials();

console.log('üîß Supabase client configuration:', {
  hasUrl: !!SUPABASE_URL,
  hasKey: !!SUPABASE_PUBLISHABLE_KEY,
  urlLength: SUPABASE_URL?.length,
  keyLength: SUPABASE_PUBLISHABLE_KEY?.length,
  urlValid: SUPABASE_URL?.startsWith('https://') && SUPABASE_URL?.includes('.supabase.co'),
  keyValid: SUPABASE_PUBLISHABLE_KEY?.startsWith('eyJ') && SUPABASE_PUBLISHABLE_KEY?.length > 100,
  hasValidCredentials,
  willUseMock: !hasValidCredentials,
  url: SUPABASE_URL ? `${SUPABASE_URL.substring(0, 30)}...` : 'missing',
  keyPrefix: SUPABASE_PUBLISHABLE_KEY ? SUPABASE_PUBLISHABLE_KEY.substring(0, 10) + '...' : 'missing'
});

// Use mock client if credentials are missing or invalid
export const supabase = hasValidCredentials ?
  createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
    auth: {
      storage: localStorage,
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      storageKey: 'supabase.auth.token',
    },
    global: {
      headers: {
        'X-Client-Info': 'backlink-infinity@1.0.0',
      },
      fetch: (url, options = {}) => {
        return fetch(url, {
          ...options,
          // Add retry logic and better error handling for network issues
        }).catch(error => {
          console.warn('Supabase fetch error (possibly due to network/third-party interference):', error);
          // Re-throw but with context
          throw new Error(`Network request failed: ${error.message}`);
        });
      },
    },
  }) :
  createMockSupabaseClient() as any;

// Log the final client type
if (hasValidCredentials) {
  console.log('‚úÖ Using real Supabase client');
} else {
  console.warn('‚ö†Ô∏è Using mock Supabase client - authentication will not work!');
  console.log('Fix: Set proper VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY environment variables');
}
