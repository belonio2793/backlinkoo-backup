// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { SecureConfig } from '../../lib/secure-config';
import { supabaseErrorHandler } from '../../utils/supabaseErrorHandler';
// Simplified imports without fetch workarounds

// Get Supabase configuration with proper fallback
const getSupabaseConfig = () => {
  const envUrl = import.meta.env.VITE_SUPABASE_URL;
  const envKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

  console.log('üîß Environment variables:', {
    hasEnvUrl: !!envUrl,
    hasEnvKey: !!envKey,
    envUrlLength: envUrl?.length || 0,
    envKeyLength: envKey?.length || 0
  });

  const url = envUrl || SecureConfig.SUPABASE_URL;
  const key = envKey || SecureConfig.SUPABASE_ANON_KEY;

  console.log('üîß Final config:', {
    url: url ? `${url.substring(0, 30)}...` : 'missing',
    keyPrefix: key ? key.substring(0, 10) + '...' : 'missing',
    urlFromEnv: !!envUrl,
    keyFromEnv: !!envKey
  });

  return { url, key };
};

const { url: SUPABASE_URL, key: SUPABASE_PUBLISHABLE_KEY } = getSupabaseConfig();

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Create a mock client for development when Supabase project is not available
const createMockSupabaseClient = () => {
  const mockUser = {
    id: 'mock-user-id',
    email: 'test@example.com',
    user_metadata: { display_name: 'Test User' },
    created_at: new Date().toISOString(),
    aud: 'authenticated'
  };

  const mockSession = {
    access_token: 'mock-access-token',
    refresh_token: 'mock-refresh-token',
    user: mockUser
  };

  const mockAuth = {
    getSession: () => {
      console.warn('‚ö†Ô∏è Mock auth getSession called - using fake session');
      return Promise.resolve({ data: { session: null }, error: { message: 'Mock mode: Please configure real Supabase credentials' } });
    },
    getUser: () => {
      console.warn('‚ö†Ô∏è Mock auth getUser called');
      return Promise.resolve({ data: { user: null }, error: { message: 'Mock mode: Please configure real Supabase credentials' } });
    },
    onAuthStateChange: (callback: any) => {
      console.warn('‚ö†Ô∏è Mock auth onAuthStateChange called');
      return { data: { subscription: { unsubscribe: () => console.log('Mock auth listener unsubscribed') } } };
    },
    signInWithPassword: () => {
      console.error('‚ö†Ô∏è Mock auth signInWithPassword called - login will fail');
      return Promise.resolve({
        data: { user: null, session: null },
        error: { message: 'Authentication not available: Please configure real Supabase credentials in environment variables' }
      });
    },
    signUp: () => {
      console.error('‚ö†Ô∏è Mock auth signUp called - signup will fail');
      return Promise.resolve({
        data: { user: null, session: null },
        error: { message: 'Authentication not available: Please configure real Supabase credentials in environment variables' }
      });
    },
    signOut: () => {
      console.log('‚ö†Ô∏è Mock auth signOut called');
      return Promise.resolve({ error: null });
    },
    resend: () => {
      console.error('‚ö†Ô∏è Mock auth resend called');
      return Promise.resolve({ error: { message: 'Email service not available in mock mode' } });
    },
    resetPasswordForEmail: () => {
      console.error('‚ö†Ô∏è Mock auth resetPasswordForEmail called');
      return Promise.resolve({ error: { message: 'Password reset not available in mock mode' } });
    },
    verifyOtp: () => {
      console.error('‚ö†Ô∏è Mock auth verifyOtp called');
      return Promise.resolve({
        data: { user: null, session: null },
        error: { message: 'OTP verification not available in mock mode' }
      });
    },

  };

  const mockFrom = (table: string) => {
    const mockMethods = {
      select: (columns?: string) => mockMethods,
      insert: (data: any) => mockMethods,
      update: (data: any) => mockMethods,
      delete: () => mockMethods,
      upsert: (data: any) => mockMethods,
      eq: (column: string, value: any) => mockMethods,
      order: (column: string, options?: any) => mockMethods,
      limit: (count: number) => mockMethods,
      filter: (column: string, operator: string, value: any) => mockMethods,
      gte: (column: string, value: any) => mockMethods,
      lte: (column: string, value: any) => mockMethods,
      gt: (column: string, value: any) => mockMethods,
      lt: (column: string, value: any) => mockMethods,
      in: (column: string, values: any[]) => mockMethods,
      is: (column: string, value: any) => mockMethods,
      neq: (column: string, value: any) => mockMethods,
      ilike: (column: string, pattern: string) => mockMethods,
      like: (column: string, pattern: string) => mockMethods,
      range: (from: number, to: number) => mockMethods,
      single: () => {
        console.warn(`‚ö†Ô∏è Mock database query on table '${table}' - no real data available`);
        return Promise.resolve({
          data: null,
          error: { message: `Database not available: Please configure real Supabase credentials. Attempted to query table: ${table}` }
        });
      },
      then: (callback: any) => {
        console.warn(`‚ö†Ô∏è Mock database query on table '${table}' - no real data available`);
        // Return mock error to indicate database is not available
        return callback({
          data: null,
          error: { message: `Database not available: Please configure real Supabase credentials. Attempted to query table: ${table}` }
        });
      }
    };
    return mockMethods;
  };

  const mockFunctions = {
    invoke: () => Promise.resolve({ data: null, error: { message: 'Mock mode - functions disabled' } }),
  };

  const mockChannel = () => ({
    on: () => mockChannel(),
    subscribe: () => {},
  });

  return {
    auth: mockAuth,
    from: mockFrom,
    functions: mockFunctions,
    channel: mockChannel,
    removeChannel: () => {},
    rpc: () => Promise.resolve({ data: null, error: { message: 'Mock mode - RPC disabled' } }),
  };
};

// Check if we have valid Supabase credentials - improved validation
const validateCredentials = () => {
  console.log('üîç Validating Supabase credentials...');

  if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
    console.error('‚ùå Missing URL or key');
    return false;
  }

  if (SUPABASE_URL.trim() === "" || SUPABASE_PUBLISHABLE_KEY.trim() === "") {
    console.error('‚ùå Empty URL or key');
    return false;
  }

  if (SUPABASE_URL.includes('your-project-url') || SUPABASE_PUBLISHABLE_KEY.includes('your-anon-key')) {
    console.error('‚ùå Placeholder values detected');
    return false;
  }

  if (!SUPABASE_URL.startsWith('https://')) {
    console.error('‚ùå URL must start with https://');
    return false;
  }

  if (!SUPABASE_URL.includes('.supabase.co')) {
    console.error('‚ùå URL must be a supabase.co domain');
    return false;
  }

  if (!SUPABASE_PUBLISHABLE_KEY.startsWith('eyJ')) {
    console.error('‚ùå Key must be a valid JWT token');
    return false;
  }

  if (SUPABASE_PUBLISHABLE_KEY.length < 50) {
    console.error('‚ùå Key too short');
    return false;
  }

  console.log('‚úÖ Credentials validation passed');
  return true;
};

const hasValidCredentials = validateCredentials();

console.log('üîß Supabase client configuration:', {
  hasUrl: !!SUPABASE_URL,
  hasKey: !!SUPABASE_PUBLISHABLE_KEY,
  urlLength: SUPABASE_URL?.length,
  keyLength: SUPABASE_PUBLISHABLE_KEY?.length,
  urlValid: SUPABASE_URL?.startsWith('https://') && SUPABASE_URL?.includes('.supabase.co'),
  keyValid: SUPABASE_PUBLISHABLE_KEY?.startsWith('eyJ') && SUPABASE_PUBLISHABLE_KEY?.length > 100,
  hasValidCredentials,
  willUseMock: !hasValidCredentials,
  url: SUPABASE_URL ? `${SUPABASE_URL.substring(0, 30)}...` : 'missing',
  keyPrefix: SUPABASE_PUBLISHABLE_KEY ? SUPABASE_PUBLISHABLE_KEY.substring(0, 10) + '...' : 'missing'
});

// Test basic connectivity if using real client
if (hasValidCredentials) {
  console.log('üîó Testing Supabase connectivity...');
}

// Create the base client
const baseClient = hasValidCredentials ?
  createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
    auth: {
      storage: localStorage,
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      storageKey: 'supabase.auth.token',
    },
    global: {
      headers: {
        'X-Client-Info': 'backlink-infinity@1.0.0',
      },
      // Enhanced fetch with timeout and error handling
      fetch: (url, options = {}) => {
        return fetch(url, {
          ...options,
          signal: AbortSignal.timeout(30000), // 30 second timeout
        }).catch(error => {
          console.error('üåê Supabase fetch error:', error);
          if (error.name === 'TimeoutError') {
            throw new Error('Network timeout - please check your connection and try again');
          }
          if (error.message?.includes('Failed to fetch')) {
            throw new Error('Network connection failed - please check your internet connection');
          }
          throw error;
        });
      },
    },
  }) :
  createMockSupabaseClient() as any;

// For now, only wrap auth to avoid breaking database methods
// TODO: Add database error handling in a future update
export const supabase = hasValidCredentials ?
  Object.create(baseClient, {
    auth: {
      value: supabaseErrorHandler.wrapAuthClient(baseClient.auth),
      enumerable: true,
      configurable: true
    }
  }) : baseClient;

// Simplified client without complex retry logic to prevent response reading issues

// Log the final client type
if (hasValidCredentials) {
  console.log('‚úÖ Using real Supabase client with retry protection');

  // Test connection in development with better error handling
  if (import.meta.env.DEV) {
    setTimeout(async () => {
      try {
        console.log('üîç Testing Supabase connectivity...');

        // First check basic connectivity
        const canConnect = await supabaseErrorHandler.checkConnectivity(SUPABASE_URL);
        if (!canConnect) {
          console.warn('‚ùå Cannot reach Supabase servers - check your internet connection');
          return;
        }

        console.log('üåê Network connectivity OK, testing database...');

        // Test database connection with retry
        const { data, error } = await supabaseErrorHandler.retryDatabase(
          () => supabase.from('blog_posts').select('id').limit(1),
          'blog_posts',
          'test_connection'
        );

        if (error) {
          console.warn('‚ö†Ô∏è Database test failed:', error.message);
          if (error.message?.includes('relation "blog_posts" does not exist')) {
            console.info('‚ÑπÔ∏è Database tables may not be created yet - this is normal for new projects');
          }
        } else {
          console.log('‚úÖ Supabase database connection test successful');
        }

      } catch (testError: any) {
        console.warn('‚ö†Ô∏è Supabase connection test failed:', testError.message);

        if (testError.message?.includes('Failed to fetch')) {
          console.error('üåê Network connectivity issue detected');
          console.info('üí° Try refreshing the page or check your internet connection');
        } else if (testError.message?.includes('timeout')) {
          console.error('‚è∞ Connection timeout - Supabase may be slow or unreachable');
        } else {
          console.error('üîß Possible configuration issue:', testError.message);
        }
      }
    }, 1000);
  }
} else {
  console.warn('‚ö†Ô∏è Using mock Supabase client - authentication will not work!');
  console.log('Fix: Set proper VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY environment variables');
}
