/**
 * URL Cleaning & Auto-Filtration Layer
 * Advanced quality assurance system for filtering and cleaning discovered URLs
 */

import { supabase } from '@/integrations/supabase/client';
import type { DiscoveryTarget } from './RecursiveDiscoveryEngine';

export interface FilterRule {
  id: string;
  name: string;
  type: 'blacklist' | 'whitelist' | 'quality' | 'technical' | 'content' | 'behavioral';
  category: 'domain' | 'url_pattern' | 'content_analysis' | 'technical_check' | 'spam_detection';
  rule: {
    pattern?: string;
    conditions: FilterCondition[];
    action: 'block' | 'flag' | 'low_priority' | 'require_review';
    severity: 'low' | 'medium' | 'high' | 'critical';
  };
  metadata: {
    description: string;
    falsePositiveRate: number;
    falseNegativeRate: number;
    accuracy: number;
    lastUpdated: Date;
    autoGenerated: boolean;
  };
  performance: {
    totalApplications: number;
    correctBlocks: number;
    falsePositives: number;
    effectiveness: number;
  };
  isActive: boolean;
}

export interface FilterCondition {
  field: string;
  operator: 'equals' | 'contains' | 'starts_with' | 'ends_with' | 'regex' | 'greater_than' | 'less_than' | 'in_range';
  value: any;
  weight: number; // 0-1, importance of this condition
}

export interface CleaningResult {
  targetId: string;
  originalUrl: string;
  cleanedUrl?: string;
  status: 'cleaned' | 'blocked' | 'flagged' | 'passed' | 'error';
  appliedRules: string[];
  qualityScore: number;
  issues: CleaningIssue[];
  recommendations: string[];
  processingTime: number;
}

export interface CleaningIssue {
  type: 'duplicate' | '404_error' | 'spam_indicator' | 'low_authority' | 'blocked_domain' | 'technical_issue' | 'content_violation';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  autoFixable: boolean;
  recommendation: string;
}

export interface QualityMetrics {
  domainAuthority: number;
  pageAuthority: number;
  spamScore: number;
  trustScore: number;
  contentQuality: number;
  technicalScore: number;
  overallScore: number;
}

export interface URLHealthCheck {
  url: string;
  httpStatus: number;
  responseTime: number;
  isAccessible: boolean;
  hasSSL: boolean;
  mobileOptimized: boolean;
  loadTime: number;
  errors: string[];
}

export class URLCleaningFilterEngine {
  private static instance: URLCleaningFilterEngine;
  private filterRules: Map<string, FilterRule> = new Map();
  private domainBlacklist: Set<string> = new Set();
  private domainWhitelist: Set<string> = new Set();
  private urlCache: Map<string, CleaningResult> = new Map();
  private processingQueue: string[] = [];
  private isProcessing = false;
  private maxCacheSize = 10000;

  private constructor() {
    this.initializeFilters();
    this.loadBlacklistsAndWhitelists();
    this.startCleaningProcessor();
  }

  public static getInstance(): URLCleaningFilterEngine {
    if (!URLCleaningFilterEngine.instance) {
      URLCleaningFilterEngine.instance = new URLCleaningFilterEngine();
    }
    return URLCleaningFilterEngine.instance;
  }

  /**
   * Initialize filter rules
   */
  private async initializeFilters(): Promise<void> {
    const defaultRules: FilterRule[] = [
      {
        id: 'spam_domains',
        name: 'Known Spam Domains',
        type: 'blacklist',
        category: 'spam_detection',
        rule: {
          conditions: [
            { field: 'domain', operator: 'in_range', value: ['spammy-sites.com', 'link-farm.net'], weight: 1.0 }
          ],
          action: 'block',
          severity: 'critical'
        },
        metadata: {
          description: 'Blocks known spam and link farm domains',
          falsePositiveRate: 0.01,
          falseNegativeRate: 0.05,
          accuracy: 0.95,
          lastUpdated: new Date(),
          autoGenerated: false
        },
        performance: {
          totalApplications: 0,
          correctBlocks: 0,
          falsePositives: 0,
          effectiveness: 0.95
        },
        isActive: true
      },
      {
        id: 'low_authority_filter',
        name: 'Low Authority Domain Filter',
        type: 'quality',
        category: 'quality',
        rule: {
          conditions: [
            { field: 'domain_authority', operator: 'less_than', value: 15, weight: 0.7 },
            { field: 'spam_score', operator: 'greater_than', value: 70, weight: 0.8 }
          ],
          action: 'low_priority',
          severity: 'medium'
        },
        metadata: {
          description: 'Deprioritizes low authority domains with high spam scores',
          falsePositiveRate: 0.15,
          falseNegativeRate: 0.10,
          accuracy: 0.80,
          lastUpdated: new Date(),
          autoGenerated: true
        },
        performance: {
          totalApplications: 0,
          correctBlocks: 0,
          falsePositives: 0,
          effectiveness: 0.80
        },
        isActive: true
      },
      {
        id: 'dead_links_filter',
        name: '404 and Dead Links Filter',
        type: 'technical',
        category: 'technical_check',
        rule: {
          conditions: [
            { field: 'http_status', operator: 'equals', value: 404, weight: 1.0 },
            { field: 'http_status', operator: 'equals', value: 500, weight: 0.8 },
            { field: 'response_time', operator: 'greater_than', value: 30000, weight: 0.6 }
          ],
          action: 'block',
          severity: 'high'
        },
        metadata: {
          description: 'Blocks 404 errors, server errors, and extremely slow sites',
          falsePositiveRate: 0.02,
          falseNegativeRate: 0.01,
          accuracy: 0.98,
          lastUpdated: new Date(),
          autoGenerated: true
        },
        performance: {
          totalApplications: 0,
          correctBlocks: 0,
          falsePositives: 0,
          effectiveness: 0.98
        },
        isActive: true
      },
      {
        id: 'duplicate_detector',
        name: 'Duplicate URL Detector',
        type: 'technical',
        category: 'url_pattern',
        rule: {
          conditions: [
            { field: 'url_similarity', operator: 'greater_than', value: 0.95, weight: 1.0 }
          ],
          action: 'flag',
          severity: 'low'
        },
        metadata: {
          description: 'Flags duplicate or near-duplicate URLs',
          falsePositiveRate: 0.05,
          falseNegativeRate: 0.08,
          accuracy: 0.90,
          lastUpdated: new Date(),
          autoGenerated: true
        },
        performance: {
          totalApplications: 0,
          correctBlocks: 0,
          falsePositives: 0,
          effectiveness: 0.90
        },
        isActive: true
      },
      {
        id: 'malware_protection',
        name: 'Malware and Phishing Protection',
        type: 'blacklist',
        category: 'spam_detection',
        rule: {
          conditions: [
            { field: 'malware_detected', operator: 'equals', value: true, weight: 1.0 },
            { field: 'phishing_suspected', operator: 'equals', value: true, weight: 1.0 }
          ],
          action: 'block',
          severity: 'critical'
        },
        metadata: {
          description: 'Blocks domains flagged for malware or phishing',
          falsePositiveRate: 0.001,
          falseNegativeRate: 0.02,
          accuracy: 0.99,
          lastUpdated: new Date(),
          autoGenerated: false
        },
        performance: {
          totalApplications: 0,
          correctBlocks: 0,
          falsePositives: 0,
          effectiveness: 0.99
        },
        isActive: true
      },
      {
        id: 'content_quality_filter',
        name: 'Content Quality Assessment',
        type: 'content',
        category: 'content_analysis',
        rule: {
          conditions: [
            { field: 'content_length', operator: 'less_than', value: 100, weight: 0.6 },
            { field: 'keyword_stuffing', operator: 'greater_than', value: 0.8, weight: 0.7 },
            { field: 'readability_score', operator: 'less_than', value: 30, weight: 0.5 }
          ],
          action: 'low_priority',
          severity: 'medium'
        },
        metadata: {
          description: 'Evaluates content quality and readability',
          falsePositiveRate: 0.20,
          falseNegativeRate: 0.15,
          accuracy: 0.75,
          lastUpdated: new Date(),
          autoGenerated: true
        },
        performance: {
          totalApplications: 0,
          correctBlocks: 0,
          falsePositives: 0,
          effectiveness: 0.75
        },
        isActive: true
      }
    ];

    defaultRules.forEach(rule => {
      this.filterRules.set(rule.id, rule);
    });

    // Load additional rules from database
    try {
      const { data: dbRules } = await supabase
        .from('filter_rules')
        .select('*')
        .eq('is_active', true)
        .order('performance->effectiveness', { ascending: false });

      if (dbRules) {
        dbRules.forEach(rule => {
          this.filterRules.set(rule.id, {
            id: rule.id,
            name: rule.name,
            type: rule.type,
            category: rule.category,
            rule: rule.rule,
            metadata: rule.metadata,
            performance: rule.performance,
            isActive: rule.is_active
          });
        });
      }
    } catch (error) {
      console.error('Failed to load filter rules:', error);
    }

    console.log(`Initialized ${this.filterRules.size} filter rules`);
  }

  /**
   * Load blacklists and whitelists
   */
  private async loadBlacklistsAndWhitelists(): Promise<void> {
    try {
      // Load domain blacklist
      const { data: blacklist } = await supabase
        .from('domain_blacklist')
        .select('domain')
        .eq('is_active', true);

      if (blacklist) {
        blacklist.forEach(item => this.domainBlacklist.add(item.domain));
      }

      // Load domain whitelist
      const { data: whitelist } = await supabase
        .from('domain_whitelist')
        .select('domain')
        .eq('is_active', true);

      if (whitelist) {
        whitelist.forEach(item => this.domainWhitelist.add(item.domain));
      }

      console.log(`Loaded ${this.domainBlacklist.size} blacklisted and ${this.domainWhitelist.size} whitelisted domains`);

    } catch (error) {
      console.error('Failed to load domain lists:', error);
    }
  }

  /**
   * Start the cleaning processor
   */
  private startCleaningProcessor(): void {
    setInterval(async () => {
      if (!this.isProcessing && this.processingQueue.length > 0) {
        this.isProcessing = true;
        await this.processCleaningQueue();
        this.isProcessing = false;
      }
    }, 5000); // Process every 5 seconds
  }

  /**
   * Clean and filter a discovered target
   */
  public async cleanAndFilter(target: DiscoveryTarget): Promise<CleaningResult> {
    const startTime = Date.now();
    const targetId = target.id;
    
    // Check cache first
    const cached = this.urlCache.get(target.url);
    if (cached && Date.now() - startTime < 300000) { // 5 minute cache
      return cached;
    }

    const result: CleaningResult = {
      targetId,
      originalUrl: target.url,
      status: 'passed',
      appliedRules: [],
      qualityScore: 0,
      issues: [],
      recommendations: [],
      processingTime: 0
    };

    try {
      // Step 1: URL Normalization and Cleaning
      result.cleanedUrl = this.normalizeURL(target.url);

      // Step 2: Quick Blacklist/Whitelist Check
      const quickCheck = this.performQuickCheck(target);
      if (quickCheck.blocked) {
        result.status = 'blocked';
        result.issues.push(...quickCheck.issues);
        result.processingTime = Date.now() - startTime;
        this.cacheResult(target.url, result);
        return result;
      }

      // Step 3: Health Check
      const healthCheck = await this.performHealthCheck(result.cleanedUrl);
      if (!healthCheck.isAccessible) {
        result.status = 'blocked';
        result.issues.push({
          type: '404_error',
          severity: 'high',
          description: `URL is not accessible (HTTP ${healthCheck.httpStatus})`,
          autoFixable: false,
          recommendation: 'Remove this target as it is not accessible'
        });
        result.processingTime = Date.now() - startTime;
        this.cacheResult(target.url, result);
        return result;
      }

      // Step 4: Quality Analysis
      const qualityMetrics = await this.analyzeQuality(target, healthCheck);
      result.qualityScore = qualityMetrics.overallScore;

      // Step 5: Apply Filter Rules
      const filterResults = await this.applyFilterRules(target, qualityMetrics, healthCheck);
      result.appliedRules = filterResults.appliedRules;
      result.issues.push(...filterResults.issues);
      result.recommendations.push(...filterResults.recommendations);

      // Step 6: Determine Final Status
      result.status = this.determineFinalStatus(filterResults, result.qualityScore);

      // Step 7: Duplicate Detection
      await this.checkForDuplicates(target, result);

      result.processingTime = Date.now() - startTime;

      // Cache and store result
      this.cacheResult(target.url, result);
      await this.storeCleaningResult(result);

      // Update filter rule performance
      await this.updateFilterPerformance(filterResults.appliedRules, result.status);

      return result;

    } catch (error) {
      console.error(`URL cleaning failed for ${target.url}:`, error);
      result.status = 'error';
      result.issues.push({
        type: 'technical_issue',
        severity: 'medium',
        description: `Processing error: ${error instanceof Error ? error.message : 'Unknown error'}`,
        autoFixable: false,
        recommendation: 'Retry processing or investigate technical issue'
      });
      result.processingTime = Date.now() - startTime;
      return result;
    }
  }

  /**
   * Normalize and clean URL
   */
  private normalizeURL(url: string): string {
    try {
      const urlObj = new URL(url);
      
      // Remove tracking parameters
      const trackingParams = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content', 'fbclid', 'gclid'];
      trackingParams.forEach(param => {
        urlObj.searchParams.delete(param);
      });

      // Remove fragment
      urlObj.hash = '';

      // Ensure lowercase domain
      urlObj.hostname = urlObj.hostname.toLowerCase();

      // Remove trailing slash for consistency
      let pathname = urlObj.pathname;
      if (pathname.endsWith('/') && pathname.length > 1) {
        pathname = pathname.slice(0, -1);
      }
      urlObj.pathname = pathname;

      return urlObj.toString();
    } catch (error) {
      console.error('URL normalization failed:', error);
      return url;
    }
  }

  /**
   * Perform quick blacklist/whitelist check
   */
  private performQuickCheck(target: DiscoveryTarget): { blocked: boolean; issues: CleaningIssue[] } {
    const issues: CleaningIssue[] = [];
    const domain = target.domain;

    // Check blacklist
    if (this.domainBlacklist.has(domain)) {
      issues.push({
        type: 'blocked_domain',
        severity: 'critical',
        description: `Domain ${domain} is on the blacklist`,
        autoFixable: false,
        recommendation: 'Remove from blacklist if this is incorrect'
      });
      return { blocked: true, issues };
    }

    // Check for obvious spam patterns
    const spamPatterns = [
      /\.(tk|ml|ga|cf)$/i, // Free TLD spam
      /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/, // IP addresses
      /localhost|127\.0\.0\.1/i,
      /test\.|demo\.|staging\./i,
      /temp|tmp/i
    ];

    for (const pattern of spamPatterns) {
      if (pattern.test(domain)) {
        issues.push({
          type: 'spam_indicator',
          severity: 'medium',
          description: `Domain matches spam pattern: ${pattern.source}`,
          autoFixable: false,
          recommendation: 'Review domain for legitimacy'
        });
      }
    }

    return { blocked: false, issues };
  }

  /**
   * Perform health check on URL
   */
  private async performHealthCheck(url: string): Promise<URLHealthCheck> {
    const startTime = Date.now();
    
    try {
      // This would use a headless browser or HTTP client
      // Simulating for now
      const simulatedCheck: URLHealthCheck = {
        url,
        httpStatus: Math.random() > 0.1 ? 200 : 404,
        responseTime: Math.floor(Math.random() * 3000) + 500,
        isAccessible: Math.random() > 0.1,
        hasSSL: url.startsWith('https'),
        mobileOptimized: Math.random() > 0.3,
        loadTime: Math.floor(Math.random() * 5000) + 1000,
        errors: []
      };

      if (simulatedCheck.httpStatus !== 200) {
        simulatedCheck.errors.push(`HTTP ${simulatedCheck.httpStatus} error`);
        simulatedCheck.isAccessible = false;
      }

      if (simulatedCheck.responseTime > 10000) {
        simulatedCheck.errors.push('Slow response time');
      }

      return simulatedCheck;

    } catch (error) {
      return {
        url,
        httpStatus: 0,
        responseTime: Date.now() - startTime,
        isAccessible: false,
        hasSSL: false,
        mobileOptimized: false,
        loadTime: 0,
        errors: [error instanceof Error ? error.message : 'Unknown error']
      };
    }
  }

  /**
   * Analyze quality metrics
   */
  private async analyzeQuality(target: DiscoveryTarget, healthCheck: URLHealthCheck): Promise<QualityMetrics> {
    // This would integrate with SEO tools APIs (Moz, Ahrefs, etc.)
    // Simulating for now
    const baseScore = Math.random() * 100;
    
    const metrics: QualityMetrics = {
      domainAuthority: Math.floor(baseScore * 0.8),
      pageAuthority: Math.floor(baseScore * 0.7),
      spamScore: Math.floor((100 - baseScore) * 0.6),
      trustScore: Math.floor(baseScore * 0.9),
      contentQuality: Math.floor(baseScore * 0.6),
      technicalScore: healthCheck.isAccessible ? Math.floor(baseScore * 0.8) : 0,
      overallScore: 0
    };

    // Calculate overall score
    metrics.overallScore = (
      metrics.domainAuthority * 0.25 +
      metrics.pageAuthority * 0.20 +
      (100 - metrics.spamScore) * 0.15 +
      metrics.trustScore * 0.20 +
      metrics.contentQuality * 0.10 +
      metrics.technicalScore * 0.10
    );

    return metrics;
  }

  /**
   * Apply filter rules
   */
  private async applyFilterRules(
    target: DiscoveryTarget,
    quality: QualityMetrics,
    health: URLHealthCheck
  ): Promise<{
    appliedRules: string[];
    issues: CleaningIssue[];
    recommendations: string[];
    shouldBlock: boolean;
  }> {
    const appliedRules: string[] = [];
    const issues: CleaningIssue[] = [];
    const recommendations: string[] = [];
    let shouldBlock = false;

    for (const rule of this.filterRules.values()) {
      if (!rule.isActive) continue;

      const matches = this.evaluateRule(rule, target, quality, health);
      if (matches.matches) {
        appliedRules.push(rule.id);
        
        if (matches.shouldBlock) {
          shouldBlock = true;
          issues.push({
            type: this.mapRuleToIssueType(rule.category),
            severity: rule.rule.severity,
            description: `Blocked by rule: ${rule.name} - ${rule.metadata.description}`,
            autoFixable: false,
            recommendation: `Rule: ${rule.name} triggered`
          });
        } else if (rule.rule.action === 'flag') {
          issues.push({
            type: this.mapRuleToIssueType(rule.category),
            severity: rule.rule.severity,
            description: `Flagged by rule: ${rule.name}`,
            autoFixable: true,
            recommendation: `Review: ${rule.metadata.description}`
          });
        }
      }
    }

    return { appliedRules, issues, recommendations, shouldBlock };
  }

  /**
   * Evaluate a single rule
   */
  private evaluateRule(
    rule: FilterRule,
    target: DiscoveryTarget,
    quality: QualityMetrics,
    health: URLHealthCheck
  ): { matches: boolean; shouldBlock: boolean } {
    let totalWeight = 0;
    let matchedWeight = 0;

    for (const condition of rule.rule.conditions) {
      totalWeight += condition.weight;
      
      const value = this.extractFieldValue(condition.field, target, quality, health);
      if (this.evaluateCondition(condition, value)) {
        matchedWeight += condition.weight;
      }
    }

    const matchThreshold = totalWeight * 0.7; // 70% of conditions must match
    const matches = matchedWeight >= matchThreshold;
    const shouldBlock = matches && rule.rule.action === 'block';

    return { matches, shouldBlock };
  }

  /**
   * Extract field value for rule evaluation
   */
  private extractFieldValue(field: string, target: DiscoveryTarget, quality: QualityMetrics, health: URLHealthCheck): any {
    const fieldMap: Record<string, any> = {
      'domain': target.domain,
      'url': target.url,
      'domain_authority': quality.domainAuthority,
      'page_authority': quality.pageAuthority,
      'spam_score': quality.spamScore,
      'trust_score': quality.trustScore,
      'http_status': health.httpStatus,
      'response_time': health.responseTime,
      'is_accessible': health.isAccessible,
      'has_ssl': health.hasSSL,
      'mobile_optimized': health.mobileOptimized
    };

    return fieldMap[field];
  }

  /**
   * Evaluate a condition
   */
  private evaluateCondition(condition: FilterCondition, value: any): boolean {
    switch (condition.operator) {
      case 'equals':
        return value === condition.value;
      case 'contains':
        return typeof value === 'string' && value.includes(condition.value);
      case 'starts_with':
        return typeof value === 'string' && value.startsWith(condition.value);
      case 'ends_with':
        return typeof value === 'string' && value.endsWith(condition.value);
      case 'regex':
        return new RegExp(condition.value).test(value);
      case 'greater_than':
        return typeof value === 'number' && value > condition.value;
      case 'less_than':
        return typeof value === 'number' && value < condition.value;
      case 'in_range':
        return Array.isArray(condition.value) && condition.value.includes(value);
      default:
        return false;
    }
  }

  /**
   * Determine final status based on filter results
   */
  private determineFinalStatus(filterResults: any, qualityScore: number): CleaningResult['status'] {
    if (filterResults.shouldBlock) {
      return 'blocked';
    }
    
    if (filterResults.issues.some((issue: CleaningIssue) => issue.severity === 'critical')) {
      return 'blocked';
    }
    
    if (filterResults.issues.some((issue: CleaningIssue) => issue.severity === 'high')) {
      return 'flagged';
    }
    
    if (qualityScore < 30) {
      return 'flagged';
    }
    
    return 'passed';
  }

  /**
   * Check for duplicates
   */
  private async checkForDuplicates(target: DiscoveryTarget, result: CleaningResult): Promise<void> {
    try {
      const { data: existingTargets } = await supabase
        .from('discovery_targets')
        .select('url, domain')
        .or(`url.eq.${target.url},domain.eq.${target.domain}`)
        .neq('id', target.id);

      if (existingTargets && existingTargets.length > 0) {
        result.issues.push({
          type: 'duplicate',
          severity: 'low',
          description: `Found ${existingTargets.length} similar target(s)`,
          autoFixable: true,
          recommendation: 'Consider consolidating or removing duplicates'
        });
      }
    } catch (error) {
      console.error('Duplicate check failed:', error);
    }
  }

  // Helper methods
  private mapRuleToIssueType(category: string): CleaningIssue['type'] {
    const mapping: Record<string, CleaningIssue['type']> = {
      'spam_detection': 'spam_indicator',
      'quality': 'low_authority',
      'technical_check': 'technical_issue',
      'url_pattern': 'duplicate',
      'content_analysis': 'content_violation',
      'domain': 'blocked_domain'
    };
    return mapping[category] || 'technical_issue';
  }

  private cacheResult(url: string, result: CleaningResult): void {
    // Implement LRU cache
    if (this.urlCache.size >= this.maxCacheSize) {
      const firstKey = this.urlCache.keys().next().value;
      this.urlCache.delete(firstKey);
    }
    this.urlCache.set(url, result);
  }

  private async processCleaningQueue(): Promise<void> {
    // Process queued cleaning tasks
    while (this.processingQueue.length > 0) {
      const targetId = this.processingQueue.shift();
      // Process target
    }
  }

  private async storeCleaningResult(result: CleaningResult): Promise<void> {
    try {
      await supabase.from('cleaning_results').insert({
        target_id: result.targetId,
        original_url: result.originalUrl,
        cleaned_url: result.cleanedUrl,
        status: result.status,
        applied_rules: result.appliedRules,
        quality_score: result.qualityScore,
        issues: result.issues,
        recommendations: result.recommendations,
        processing_time: result.processingTime,
        processed_at: new Date().toISOString()
      });
    } catch (error) {
      console.error('Failed to store cleaning result:', error);
    }
  }

  private async updateFilterPerformance(appliedRules: string[], status: string): Promise<void> {
    for (const ruleId of appliedRules) {
      const rule = this.filterRules.get(ruleId);
      if (rule) {
        rule.performance.totalApplications++;
        
        // Update effectiveness based on outcome
        if (status === 'blocked' && rule.rule.action === 'block') {
          rule.performance.correctBlocks++;
        }
        
        rule.performance.effectiveness = 
          rule.performance.correctBlocks / rule.performance.totalApplications;
        
        // Store update
        try {
          await supabase
            .from('filter_rules')
            .update({ performance: rule.performance })
            .eq('id', ruleId);
        } catch (error) {
          console.error(`Failed to update rule performance for ${ruleId}:`, error);
        }
      }
    }
  }

  // Public API methods
  public async batchCleanAndFilter(targets: DiscoveryTarget[]): Promise<CleaningResult[]> {
    const results: CleaningResult[] = [];
    
    for (const target of targets) {
      try {
        const result = await this.cleanAndFilter(target);
        results.push(result);
      } catch (error) {
        console.error(`Batch cleaning failed for ${target.url}:`, error);
        results.push({
          targetId: target.id,
          originalUrl: target.url,
          status: 'error',
          appliedRules: [],
          qualityScore: 0,
          issues: [{
            type: 'technical_issue',
            severity: 'medium',
            description: 'Batch processing error',
            autoFixable: false,
            recommendation: 'Retry individual processing'
          }],
          recommendations: [],
          processingTime: 0
        });
      }
      
      // Add delay to prevent overwhelming
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    return results;
  }

  public getFilterRules(): FilterRule[] {
    return Array.from(this.filterRules.values());
  }

  public async addToBlacklist(domain: string, reason: string): Promise<void> {
    this.domainBlacklist.add(domain);
    
    try {
      await supabase.from('domain_blacklist').insert({
        domain,
        reason,
        added_at: new Date().toISOString(),
        is_active: true
      });
    } catch (error) {
      console.error('Failed to add to blacklist:', error);
    }
  }

  public async addToWhitelist(domain: string, reason: string): Promise<void> {
    this.domainWhitelist.add(domain);
    
    try {
      await supabase.from('domain_whitelist').insert({
        domain,
        reason,
        added_at: new Date().toISOString(),
        is_active: true
      });
    } catch (error) {
      console.error('Failed to add to whitelist:', error);
    }
  }

  public getCleaningStats(): {
    totalProcessed: number;
    passed: number;
    blocked: number;
    flagged: number;
    averageQualityScore: number;
    averageProcessingTime: number;
  } {
    const results = Array.from(this.urlCache.values());
    
    return {
      totalProcessed: results.length,
      passed: results.filter(r => r.status === 'passed').length,
      blocked: results.filter(r => r.status === 'blocked').length,
      flagged: results.filter(r => r.status === 'flagged').length,
      averageQualityScore: results.reduce((sum, r) => sum + r.qualityScore, 0) / results.length || 0,
      averageProcessingTime: results.reduce((sum, r) => sum + r.processingTime, 0) / results.length || 0
    };
  }
}

export default URLCleaningFilterEngine;
